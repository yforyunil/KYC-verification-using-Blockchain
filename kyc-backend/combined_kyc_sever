// SPDX-License-Identifier: MIT
import { create } from 'ipfs-http-client';
import Web3 from 'web3';
import fs from 'fs/promises';
import path from 'path';
import fetch from 'node-fetch';
import chokidar from 'chokidar';

// IPFS and blockchain configuration
const ipfs = create('http://localhost:5001');
const web3 = new Web3('http://localhost:8545');

// Directories for input JSON and saving output
const uploadDir = '/home/ubuntu/FinalProject/KYC-verification-using-Blockchain/KYC_JSON';
const verifyDir = '/home/ubuntu/FinalProject/KYC-verification-using-Blockchain/To_verify_hashes_JSON';

// Frappe API URLs for uploads and verifications
const frappeUploadApiUrl = 'https://project.dndts.net/api/resource/Blockchain Hash';
const frappeVerifyApiUrl = 'https://project.dndts.net/api/resource/Verified KYC Forms';

// Function to get contract address dynamically
async function getContractAddress() {
    const contractJsonPath = path.join('/home/ubuntu/FinalProject/KYC-verification-using-Blockchain/build/contracts', 'KYCDocument.json');
    try {
        const contractJson = await fs.readFile(contractJsonPath, 'utf8');
        const contractData = JSON.parse(contractJson);
        const networkId = await web3.eth.net.getId();
        return contractData.networks[networkId].address;
    } catch (error) {
        console.error('Error reading contract address:', error);
        throw error;
    }
}

// Function to get contract ABI
async function getContractABI() {
    const contractJsonPath = path.join('/home/ubuntu/FinalProject/KYC-verification-using-Blockchain/build/contracts', 'KYCDocument.json');
    try {
        const contractJson = await fs.readFile(contractJsonPath, 'utf8');
        const contractData = JSON.parse(contractJson);
        return contractData.abi;
    } catch (error) {
        console.error('Error reading contract ABI:', error);
        throw error;
    }
}

// Function to upload a JSON file to IPFS
async function uploadToIPFS(data) {
    try {
        const result = await ipfs.add(data);
        return result.path;
    } catch (error) {
        console.error('Error uploading to IPFS:', error);
        throw error;
    }
}

// Function to save the IPFS hash, transaction hash, and filename to a JSON file
async function saveHashes(filename, ipfsHash, txHash, owner) {
    const outputDir = '/home/ubuntu/FinalProject/KYC-verification-using-Blockchain/hashes_IPFS_Blockchain';
    try {
        const outputData = { filename, ipfsHash, txHash, owner };
        const outputFilePath = path.join(outputDir, `${filename}.result.json`);
        await fs.writeFile(outputFilePath, JSON.stringify(outputData, null, 2));
        console.log(`Saved hashes to ${outputFilePath}`);
        return outputData;
    } catch (error) {
        console.error('Error saving hashes:', error);
        throw error;
    }
}

// Function to send uploaded hashes to the upload API
async function sendToUploadApi(data) {
    const { ipfsHash, txHash, owner } = data;
    const frappeData = {
        ipfs_hash: ipfsHash,
        blockchain_hash: txHash,
        docstatus: 1,
       owner: owner // Include the owner payload from the input file
    };
    try {
        const response = await fetch(frappeUploadApiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(frappeData)
        });

        if (!response.ok) {
            throw new Error(`Failed to send data to Upload API: ${response.statusText}`);
        }

        const responseData = await response.json();
        console.log('Successfully sent data to Upload API:', responseData);
    } catch (error) {
        console.error('Error sending data to Upload API:', error);
    }
}

// Function to send verified documents to the verification API
async function sendToVerifyApi(data) {
    try {
        const response = await fetch(frappeVerifyApiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error(`Failed to send data to Verify API: ${response.statusText}`);
        }

        const responseData = await response.json();
        console.log('Successfully sent data to Verify API:', responseData);
    } catch (error) {
        console.error('Error sending data to Verify API:', error);
    }
}

// Function to upload a document (KYC creation)
async function uploadDocument(filePath) {
    try {
        const filename = path.basename(filePath);
        const jsonData = await fs.readFile(filePath, 'utf8');
        const { owner, ...data } = JSON.parse(jsonData);

        // Upload JSON to IPFS
        const ipfsHash = await uploadToIPFS(Buffer.from(JSON.stringify(data)));

        // Get contract address and ABI dynamically
        const contractAddress = await getContractAddress();
        const contractABI = await getContractABI();
        const contract = new web3.eth.Contract(contractABI, contractAddress);

        // Upload IPFS hash to blockchain
        const accounts = await web3.eth.getAccounts();
        const gasPrice = await web3.eth.getGasPrice();
        const receipt = await contract.methods.addDocument(ipfsHash).send({
            from: accounts[0],
            gas: 3000000,
            gasPrice
        });
        const txHash = receipt.transactionHash;

        // Save IPFS hash, transaction hash, and owner
        const outputData = await saveHashes(filename, ipfsHash, txHash, owner);

        // Send data to Upload API
        await sendToUploadApi(outputData);
    } catch (error) {
        console.error('Error uploading document:', error);
    }
}

// Function to verify document (KYC verification)
async function verifyDocument(filePath) {
    let statusFlag = '';

    try {
        const filename = path.basename(filePath);
        const jsonData = await fs.readFile(filePath, 'utf8');
        const { ipfsHash: originalIpfsHash, blockchainHash, owner } = JSON.parse(jsonData);

        // Get contract address and ABI dynamically
        const contractAddress = await getContractAddress();
        const contractABI = await getContractABI();
        const contract = new web3.eth.Contract(contractABI, contractAddress);

        // Fetch IPFS hash from blockchain
        let storedIpfsHash;
        try {
            storedIpfsHash = await contract.methods.getDocument(blockchainHash).call();
        } catch (error) {
            console.error('Error fetching IPFS hash from blockchain:', error);
            statusFlag = 'no block';
        }

        // Compare the IPFS hashes
        if (storedIpfsHash !== originalIpfsHash) {
            statusFlag = 'ipfs hash different';
        } else {
            let kycInfo;
            try {
                kycInfo = await ipfs.cat(storedIpfsHash);
                statusFlag = 'verified';
            } catch (error) {
                console.error('Error fetching KYC from IPFS:', error);
                statusFlag = 'error';
            }

            if (statusFlag === 'verified') {
                const kycData = JSON.parse(kycInfo);
                const responseData = { ...kycData, Status: statusFlag, owner };
                await sendToVerifyApi(responseData);
            }
        }
    } catch (error) {
        console.error('Error verifying document:', error);
        statusFlag = 'error';
    }
}

// Watch both directories for new JSON files
const watcher = chokidar.watch([uploadDir, verifyDir], {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: { stabilityThreshold: 2000, pollInterval: 100 }
});

// Handle new files in respective directories
watcher.on('add', filePath => {
    console.log(`New file detected: ${filePath}`);

    if (filePath.startsWith(uploadDir)) {
        uploadDocument(filePath); // Process KYC upload
    } else if (filePath.startsWith(verifyDir)) {
        verifyDocument(filePath); // Process KYC verification
    }
});

// Handle watcher errors
watcher.on('error', error => console.error('Watcher error:', error));

console.log(`Watching directories: ${uploadDir} and ${verifyDir} for new JSON files...`);
